---
title: "P8105_HW1_msp2210"
output: github_document
author: "Mukta Patwari"
date: "2025-09-18"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Problem 1

**Loading libraries**

```{r}
library(tidyverse)
library(moderndive)
```

**Loading the dataset**

```{r}
data("early_january_weather")
```

This dataset has `r nrow(early_january_weather)` rows and `r ncol(early_january_weather)` columns. This dataset has 15 variables, which are `r names(early_january_weather)`. The mean temperature is `r mean(pull(early_january_weather, temp))` degrees Fahrenheit.

Other important variables include those related to humidity and precipitation. The mean dew point was `r mean(pull(early_january_weather, dewp))` degrees Fahrenheit, the mean humidity was `r mean(pull(early_january_weather, humid))`%, and the mean precipitation was `r mean(pull(early_january_weather, precip))` inches. The average wind speed during this month was `r mean(pull(early_january_weather, wind_speed))` mph.

**Creating a scatterplot**

```{r}
ggplot(early_january_weather, aes(x = time_hour, y = temp, color=humid)) + geom_point()
```

Based on this plot, it is clear how temperature fluctuates throughout the day. There is a  zig-zag effect, because higher temperatures are occurring during the day and then they decline at night (and this is a cycle that continues throughout the month). The beginning of the month has cooler temperatures during daytime and nighttime, and by January 14th, both of these temperatures have increased. Also, there was less humidity at the beginning of the month when compared to the days leading up to January 14th.

**Saving scatterplot to directory**

```{r}
ggsave("p8105_hw1_msp2210_scatterplot.pdf", height = 4, width = 6)
```

## Problem 2

**Creating dataframe**

```{r}
problem2_df =
  tibble(
    random_samp = rnorm(10),
    vec_logical = random_samp > 10,
    vec_char = c("wildebeest", "giraffe", "zebra", "elephant", "lion", "hippo", "warthog", "rhino", "ostrich", "flamingo"),
    vec_factor = factor(c("Level 1", "Level 2", "Level 3", "Level 2", "Level 3", "Level 3", "Level 2", "Level 1", "Level 2", "Level 3"))
)
```

**Taking means of variables**
```{r}
mean(pull(problem2_df, random_samp))
mean(pull(problem2_df, vec_logical))
mean(pull(problem2_df, vec_char))
mean(pull(problem2_df, vec_factor))
```

The random sample variable and the logical vector produce numeric values, but the character and factor variables do not, they result in "NA". As they are not numeric, it is not possible to take the arithmetic mean.

**Converting variables to numeric variables**
```{r eval = FALSE}
as.numeric(pull(problem2_df, vec_logical))
as.numeric(pull(problem2_df, vec_char))
as.numeric(pull(problem2_df, vec_factor))
```

Now that the variables have numeric values, it is possible to take the mean. For the logical vector, the "TRUE" values become 1 and the "FALSE" values become 0, which means that taking the mean of this vector will give you an actual number (and this is what happened - even before using the as.numeric() function, I was able to take the mean of the logical vector). For the character vector, the as.numeric() function cannot convert character strings into numeric values, so NAs are introduced by coercion. For the factor vector, the as.numeric function converts the factors into numbers based on the levels, which means it will now be possible to take the mean. Initially, we were unable to find the mean of these variables because they were not numeric variables.